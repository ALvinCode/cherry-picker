!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(require("child_process"),require("inquirer"),require("chalk")):"function"==typeof define&&define.amd?define(["child_process","inquirer","chalk"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).child_process,e.inquirer,e.chalk)}(this,(function(e,t,o){"use strict";function r(e){try{const t=/^git@([^:]+):([^/]+)\/(.+)\.git$/,o=/^https?:\/\/([^/]+)\/([^/]+)\/(.+)\.git$/;let r;if(r=e.match(t)){const[,e,t,o]=r;return`https://${e}/${t}/${o}.git`}if(r=e.match(o)){const[,e,t,o]=r;return`https://${e}/${t}/${o}.git`}throw new Error("The URL does not conform to the specified format. Please check and try again.")}catch(t){console.error(o.red(`Error standardizing URL: ${t.message}`)),process.exit(1)}}const n=async()=>{const{sourceBranch:e}=await t.prompt([{type:"input",name:"sourceBranch",message:"Enter the source branch name:",validate:e=>!!e||"Source branch name is required."}]);return e?e.trim():""},c=async(r,n)=>{try{const i=await(c=r,s=n,new Promise(((t,r)=>{e.exec(`git fetch ${c} ${s} && git log ${c}/${s} --pretty=format:"%ad %an > %s - %h" --date=format:'%Y-%m-%d %H:%M:%S'`,((e,n)=>{e&&r(new Error(`Pulling commits from branch "${s}" failed. Please check the branch.`));const c=n.split("\n").map(((e,t)=>{const[r,...n]=e.split(" - "),c=n.join(" - ");return{name:`${0===t?o.green(r):r} (${c})`,value:c.trim()}}));t(c)}))}))),{selectedCommit:a}=await t.prompt([{type:"list",name:"selectedCommit",message:`Please select a commit record to perform cherry-pick (branch: ${n}):`,choices:i,loop:!1,pageSize:10}]);return a}catch(i){console.error(o.red(i)),process.exit(1)}var c,s},s=async()=>{const{targetBranch:e}=await t.prompt([{type:"input",name:"targetBranch",message:"Enter the target branch name:",validate:e=>!!e||"Target branch name is required."}]);return e?e.trim():""};function i(e){try{const t=/^(?:https?:\/\/|git@)(?:[^/:]+)[/:]([^/]+\/[^/.]+)(?:\.git)?$/i,o=e.match(t);if(o){const e=o[1];return e.split("/").pop()}return console.log("Failed to resolve project name, using default name: source-repo"),"source-repo"}catch(t){return console.log("Error to resolve project name, using default name: source-repo"),"source-repo"}}async function a(){try{let c="";const{inputRepoUrl:s}=await t.prompt([{type:"input",name:"inputRepoUrl",message:"Enter the source repository URL:",validate:e=>!!e||"Source repository URL is required."}]);if(function(e){try{const t=l().map((e=>e.split(" : ")[1])).filter(Boolean).map((e=>e.split(" ")[0])).filter(Boolean).map(r),o=r(e);return t.includes(o)}catch(t){console.error(o.red(t.message)),process.exit(1)}}(s)){const{useRemote:e}=await t.prompt([{type:"confirm",name:"useRemote",message:`Remote repository "${s}" already exists, do you want to use it?`,default:!0}]);if(!e)return await a();c=s}else try{console.log(o.greenBright("Adding from source repository..."));const t=i(s);e.execSync(`git remote add ${t} ${s}`,{stdio:"ignore"}),c=s}catch(n){console.error(o.red(n.message)),process.exit(1)}return c}catch(n){console.error(o.red(n.message)),process.exit(1)}}function l(){try{return e.execSync("git remote -v",{encoding:"utf-8"}).toString().trim().split("\n").map((e=>e.replace("\t"," : "))).filter((e=>e.includes("(fetch)")&&!e.includes("undefined")&&!e.includes("origin:")))}catch(t){console.error(o.red(t.message)),process.exit(1)}}function u(t){console.log(o.yellowBright(`Checking if target branch "${t}" exists...`));try{return""!==e.execSync(`git branch --list ${t}`,{encoding:"utf-8"}).trim()}catch(r){console.error("Failed to check if branch exists."),process.exit(1)}}function m(t,r){try{u(t)&&(!function(t){try{e.execSync(`git branch -D ${t}`,{stdio:"ignore"}),console.log(o.gray(`Clean up temporary branches with duplicate names "${t}".`))}catch(r){console.error(o.red(`Cleaning up temporary branch - "${t}" failed .`)),process.exit(1)}}(t),console.log()),e.execSync(`git checkout -b ${t} ${r}`),console.log(`Create and switch to a new temporary branch - "${t}".`),console.log()}catch(n){console.error(o.red(`Failed to create and switch to a new temporary branch - "${t}". ${n.message}`)),process.exit(1)}}process.on("SIGINT",(()=>{console.log("\nOperation aborted by user."),process.exit(1)})),async function(){const{lastRemoteName:r,lastRemoteUrl:g}=function(){const e={lastRemoteName:null,lastRemoteUrl:null};try{const t=l();if(console.log("Connected warehouse",t),0===t.length)return e;if(t){const[e,o]=t[0].split(" : ");return{lastRemoteName:e.split("/").slice(-1)[0],lastRemoteUrl:o.split(" ")[0]}}return e}catch(t){return console.error("Failed to retrieve git remotes:",t),e}}(),{usingRemoteUrl:h,usingRemoteName:p}=await async function(e,r){try{let o,n;if("string"==typeof e&&"undefined"!==e&&"null"!==e&&e){const{useExistingRemote:n}=await t.prompt([{type:"confirm",name:"useExistingRemote",message:`Use the most recently added remote repository "${e}"?`,default:!0}]);o=n?r:await a()}else o=await a();return n=i(o),{usingRemoteUrl:o,usingRemoteName:n}}catch(n){console.error(o.red(n.message)),process.exit(1)}}(r,g);try{const r=await n(),i=await c(p,r),a=await s();!function(e,t,r,n,c){const s=[{"Confirmation Item":"Source project    ",Value:o.yellow(e)},{"Confirmation Item":"Source repo       ",Value:o.yellow(t)},{"Confirmation Item":"Source branch     ",Value:o.yellow(r)},{"Confirmation Item":"Source commit hash",Value:o.yellow(n)},{"Confirmation Item":"Target branch     ",Value:o.yellow(c)}];console.log(o.bold("Confirmation Item   |  Value")),console.log("----------------------------"),s.forEach((e=>{console.log(`${e["Confirmation Item"]}  |  ${e.Value}`)})),console.log()}(p,h,r,i,a),console.log(o.greenBright("Fetching from source repository...")),e.execSync(`git fetch ${p} ${r}`),console.log(),m(`temp-${r}`,`${p}/${r}`),function(t){u(t)?(console.log(`The target branch already exists, switch to the target branch - "${t}"...`),e.execSync(`git checkout ${t}`),console.log()):(console.log(`Target branch does not exist, create and switch to the target branch - "${t}"...`),e.execSync(`git checkout -b ${t}`),e.execSync(`git push -u origin ${t}`),console.log())}(a),function(t){return console.log(o.greenBright(`Cherry-picking commit ${t}...`)),new Promise(((r,n)=>{try{const n=e.spawn("git",["cherry-pick",t]);let c=!0;n.stdout.on("data",(e=>{console.log(`[stdout] ${e}`)})),n.stderr.on("data",(t=>{console.error(`[stderr] ${t}`),c&&(e.execSync("git status",{stdio:"inherit"}),c=!1)})),n.on("close",(e=>{0===e&&(console.log(o.greenBright("Cherry-pick successful")),r())}))}catch(c){n(c)}}))}(i).then((async()=>{const n=await t.prompt([{type:"confirm",name:"pushChanges",message:"Do you want to push the changes to the remote repository?"}]);console.log("Waiting push..."),n.pushChanges?(e.execSync(`git push -f origin temp-${r}:${a}`,{stdio:"inherit"}),console.log(o.green("Changes successfully pushed."))):console.log(o.yellow("Merge completed but not pushed."))})).catch((e=>{console.error(o.red(`Cherry-pick failed. Resolve the conflicts and perform the merge manually. ${e}`))}))}catch(d){console.error(o.red(d.message)),process.exit(1)}}()}));

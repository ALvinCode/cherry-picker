!function(e,o){"object"==typeof exports&&"undefined"!=typeof module?o(require("child_process"),require("inquirer"),require("chalk")):"function"==typeof define&&define.amd?define(["child_process","inquirer","chalk"],o):o((e="undefined"!=typeof globalThis?globalThis:e||self).child_process,e.inquirer,e.chalk)}(this,(function(e,o,t){"use strict";function r(e){try{const o=/^git@([^:]+):([^/]+)\/(.+)\.git$/,t=/^https?:\/\/([^/]+)\/([^/]+)\/(.+)\.git$/;let r;if(r=e.match(o)){const[,e,o,t]=r;return`https://${e}/${o}/${t}.git`}if(r=e.match(t)){const[,e,o,t]=r;return`https://${e}/${o}/${t}.git`}throw new Error("The URL does not conform to the specified format. Please check and try again.")}catch(o){console.error(t.red(`Error standardizing URL: ${o.message}`)),process.exit(1)}}const n=async()=>{const{sourceBranch:e}=await o.prompt([{type:"input",name:"sourceBranch",message:"Enter the source branch name:",validate:e=>!!e||"Source branch name is required."}]);return e?e.trim():""},c=async(r,n)=>{try{const i=await(c=r,s=n,new Promise(((o,r)=>{e.exec(`git fetch ${c} ${s} && git log ${c}/${s} --pretty=format:"%ad %an > %s - %h" --date=format:'%Y-%m-%d %H:%M:%S'`,((e,n)=>{e&&r(new Error(`Pulling commits from branch "${s}" failed. Please check the branch.`));const c=n.split("\n").map(((e,o)=>{const[r,...n]=e.split(" - "),c=n.join(" - ");return{name:`${0===o?t.green(r):r} (${c})`,value:c.trim()}}));o(c)}))}))),{selectedCommit:a}=await o.prompt([{type:"list",name:"selectedCommit",message:`Please select a commit record to perform cherry-pick (branch: ${n}):`,choices:i,loop:!1,pageSize:10}]);return a}catch(i){console.error(t.red(i)),process.exit(1)}var c,s},s=async()=>{const{targetBranch:e}=await o.prompt([{type:"input",name:"targetBranch",message:"Enter the target branch name:",validate:e=>!!e||"Target branch name is required."}]);return e?e.trim():""};function i(e){try{const o=/^(?:https?:\/\/|git@)(?:[^/:]+)[/:]([^/]+\/[^/.]+)(?:\.git)?$/i,t=e.match(o);if(t){const e=t[1];return e.split("/").pop()}return console.log("Failed to resolve project name, using default name: source-repo"),"source-repo"}catch(o){return console.log("Error to resolve project name, using default name: source-repo"),"source-repo"}}async function a(){try{let c="";const{inputRepoUrl:s}=await o.prompt([{type:"input",name:"inputRepoUrl",message:"Enter the source repository URL:",validate:e=>!!e||"Source repository URL is required."}]);if(function(e){try{const o=l().map((e=>e.split(" : ")[1])).filter(Boolean).map((e=>e.split(" ")[0])).filter(Boolean).map(r),t=r(e);return o.includes(t)}catch(o){console.error(t.red(o.message)),process.exit(1)}}(s)){const{useRemote:e}=await o.prompt([{type:"confirm",name:"useRemote",message:`Remote repository "${s}" already exists, do you want to use it?`,default:!0}]);if(!e)return await a();c=s}else try{console.log(t.greenBright("Adding from source repository..."));const o=i(s);e.execSync(`git remote add ${o} ${s}`,{stdio:"ignore"}),c=s}catch(n){console.error(t.red(n.message)),process.exit(1)}return c}catch(n){console.error(t.red(n.message)),process.exit(1)}}function l(){try{return e.execSync("git remote -v",{encoding:"utf-8"}).toString().trim().split("\n").map((e=>e.replace("\t"," : "))).filter((e=>e.includes("(fetch)")&&!e.includes("undefined")&&!e.includes("origin:")))}catch(o){console.error(t.red(o.message)),process.exit(1)}}function u(o){console.log(t.yellowBright(`Checking if target branch "${o}" exists...`));try{return""!==e.execSync(`git branch --list ${o}`,{encoding:"utf-8"}).trim()}catch(r){console.error("Failed to check if branch exists."),process.exit(1)}}function h(o,r){try{u(o)&&(!function(o){try{e.execSync(`git branch -D ${o}`,{stdio:"ignore"}),console.log(t.gray(`Clean up temporary branches with duplicate names "${o}".`))}catch(r){console.error(t.red(`Cleaning up temporary branch - "${o}" failed .`)),process.exit(1)}}(o),console.log()),e.execSync(`git checkout -b ${o} ${r}`),console.log(`Create and switch to a new temporary branch - "${o}".`),console.log()}catch(n){console.error(t.red(`Failed to create and switch to a new temporary branch - "${o}". ${n.message}`)),process.exit(1)}}process.on("SIGINT",(()=>{console.log("\nOperation aborted by user."),process.exit(1)})),async function(){try{let r,m,g,p,d;const f=function(e){try{if(!fs.existsSync(e))return console.log(t.red(`Configuration file ${e} does not exist.`)),null;const o=fs.readFileSync(e,"utf-8"),r=JSON.parse(o);return console.log(t.green("Successfully loaded the configuration file: ")),console.log(r),r}catch(o){return console.error(t.red("An error occurred while reading or parsing the configuration file: "),o),null}}(path.resolve(process.cwd(),".crcpconfig.json"));if(f){f.sourceRepoUrl||(console.error(t.red("The source repository URL is missing in the configuration file.")),process.exit(1)),f.targetBranch||(console.error(t.red("The target branch is missing in the configuration file.")),process.exit(1)),f.sourceBranch||(console.error(t.red("The source branch is missing in the configuration file.")),process.exit(1)),f.commitHash||(console.error(t.red("The commit hash is missing in the configuration file.")),process.exit(1));const{sourceRepoUrl:e,sourceBranch:o,commitHash:n,targetBranch:c}=f;r=getRepoNameFromUrl(e),m=e,g=o,p=n,d=c}else{const{lastRemoteName:e,lastRemoteUrl:u}=function(){const e={lastRemoteName:null,lastRemoteUrl:null};try{const o=l();if(console.log("Connected warehouse",o),0===o.length)return e;if(o){const[e,t]=o[0].split(" : ");return{lastRemoteName:e.split("/").slice(-1)[0],lastRemoteUrl:t.split(" ")[0]}}return e}catch(o){return console.error("Failed to retrieve git remotes:",o),e}}(),{remoteUrl:h,remoteName:f}=await async function(e,r){try{let t,n;if("string"==typeof e&&"undefined"!==e&&"null"!==e&&e){const{useExistingRemote:n}=await o.prompt([{type:"confirm",name:"useExistingRemote",message:`Use the most recently added remote repository "${e}"?`,default:!0}]);t=n?r:await a()}else t=await a();return n=i(t),{remoteUrl:t,remoteName:n}}catch(n){console.error(t.red(n.message)),process.exit(1)}}(e,u);r=f,m=h,g=await n();p=await c(r,g),d=await s()}!function(e,o,r,n,c){const s=[{"Confirmation Item":"Source project    ",Value:t.yellow(e)},{"Confirmation Item":"Source repo       ",Value:t.yellow(o)},{"Confirmation Item":"Source branch     ",Value:t.yellow(r)},{"Confirmation Item":"Source commit hash",Value:t.yellow(n)},{"Confirmation Item":"Target branch     ",Value:t.yellow(c)}];console.log(t.bold("Confirmation Item   |  Value")),console.log("----------------------------"),s.forEach((e=>{console.log(`${e["Confirmation Item"]}  |  ${e.Value}`)})),console.log()}(r,m,g,p,d),console.log(t.greenBright("Fetching from source repository...")),e.execSync(`git fetch ${r} ${g}`),console.log(),h(`temp-${g}`,`${r}/${g}`),function(o){u(o)?(console.log(`The target branch already exists, switch to the target branch - "${o}"...`),e.execSync(`git checkout ${o}`),console.log()):(console.log(`Target branch does not exist, create and switch to the target branch - "${o}"...`),e.execSync(`git checkout -b ${o}`),e.execSync(`git push -u origin ${o}`),console.log())}(d),function(o){return console.log(t.greenBright(`Cherry-picking commit ${o}...`)),new Promise(((r,n)=>{try{const n=e.spawn("git",["cherry-pick",o]);let c=!0;n.stdout.on("data",(e=>{console.log(`[stdout] ${e}`)})),n.stderr.on("data",(o=>{console.error(`[stderr] ${o}`),c&&(e.execSync("git status",{stdio:"inherit"}),c=!1)})),n.on("close",(e=>{0===e&&(console.log(t.greenBright("Cherry-pick successful")),r())}))}catch(c){n(c)}}))}(p).then((async()=>{const r=await o.prompt([{type:"confirm",name:"pushChanges",message:"Do you want to push the changes to the remote repository?"}]);console.log("Waiting push..."),r.pushChanges?(e.execSync(`git push -f origin temp-${g}:${d}`,{stdio:"inherit"}),console.log(t.green("Changes successfully pushed."))):console.log(t.yellow("Merge completed but not pushed."))})).catch((e=>{console.error(t.red(`Cherry-pick failed. Resolve the conflicts and perform the merge manually. ${e}`))}))}catch(r){console.error(t.red(r.message)),process.exit(1)}}()}));
